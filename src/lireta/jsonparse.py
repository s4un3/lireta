import json
import importlib.util
import sys
import os
from .instrument import Track, Instrument
from .base import Keyword


def processjson(
    path: str,
    visited_jsons: list[str] = [],
    keywords_collected: list[type[Keyword]] = [],
    instruments: dict[str, type[Instrument]] = {},
    # `instruments` have a redundancy since both the key and the field in the element have (or should have) the same value, but it makes coding it more straightforward
):
    """Takes a json path entry point and gathers all info available

    All parameters except `path` should not be used except for recursive calls"""

    if path in visited_jsons:
        raise RecursionError("Circular preloading")
    visited_jsons.append(path)

    with open(path, "r") as file:
        data = json.load(file)

    if "preloads" in data:
        if not isinstance(data["preloads"], list):
            raise TypeError("'preloads' must be a list")
        # other json scripts that should be loaded before this one
        # useful if you are extending an existing config file and don't want to edit it
        for preload in data["preloads"]:
            processjson(preload, visited_jsons, keywords_collected, instruments)

    if "scripts" in data:
        if not isinstance(data["scripts"], list):
            raise TypeError("'scripts' must be a list")
        # python files that implement custom keywords or instruments
        for script_path in data["scripts"]:
            spec = importlib.util.spec_from_file_location("userscript", script_path)

            if spec is None:
                raise ImportError("Failed to create module spec from file location.")

            usermodule = importlib.util.module_from_spec(spec)

            if usermodule is None:
                raise RuntimeError("Failed to create module from spec.")

            sys.modules["userscript"] = usermodule
            loader = spec.loader

            if loader is None:
                raise RuntimeError("Module loader is None. Unable to load module.")

            loader.exec_module(usermodule)

            # all of that is to properly set `usermodule` based on a path found in the json

            try:
                available_keywords = usermodule.available_keywords
            except AttributeError:
                available_keywords = []

            for keyword in available_keywords:
                if not issubclass(keyword, Keyword):
                    raise TypeError(
                        "All elements of 'available_keywords' must be classes that inherits from Keyword"
                    )
                keywords_collected.append(keyword)

            try:
                available_instruments = usermodule.available_instruments
            except AttributeError:
                available_instruments = []

            for instrument in available_instruments:
                if not issubclass(instrument, Instrument):
                    raise TypeError(
                        "All elements of 'available_instruments' must be classes that inherits from Instrument"
                    )
                instruments[instrument._name] = instrument

    if "instruments" in data:
        # for instruments assembled in json
        # instrument creation by scripts (in python) is also possible and arguably more powerful, but this is much easier and accessible for the average user
        name = os.path.basename(path)[:-5]
        # get the name of the file and remove the ".json"
        for instrument in data["instruments"]:
            instrument = str(instrument)
            if instrument in instruments:
                raise ValueError(
                    f"Instrument named '{instrument}' already exists. Try renaming the json to change the namespace."
                )

            instr_data: dict = data["instruments"][instrument]
            tracks = []  # tracks that will be used in the instrument
            for track in instr_data["tracks"]:
                tracks.append(Track(track, instr_data["tracks"][track]))

            instr_data.pop("tracks")
            # remove the tracks from the dict generated by parsing this instrument section of the json
            # all other things (such as interpolation, pitchless and continuous) should remain

            instr_class = type(instrument, (Instrument,), {})
            # creates a class from Instrument for this instrument
            instr_class._name = instrument  # gives it a name (with namespacing based on what json file created it)
            instr_class._tracks = tracks  # fills in the tracks
            instr_class._fill(**instr_data)
            # populates the rest of the fields with the other things (interpolation, pitchless and continuous)

            instruments[instr_class._name] = instr_class
            # finally puts it in the dictionary

    return keywords_collected, instruments
